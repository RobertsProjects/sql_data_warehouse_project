-- Advance analytics

-- Calculate data changes overtime
SELECT 
order_date,
SUM(sales_amount) AS total_sales
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY order_date
ORDER BY order_date;


SELECT
DATETRUNC(month, order_date) AS order_date,
SUM(sales_amount) AS total_sales,
COUNT(DISTINCT customer_key) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(month, order_date)
ORDER BY DATETRUNC(month, order_date);


-- Cumulative analytics
-- find running total sales per month 
SELECT order_date, total_sales, 
SUM(total_sales) OVER(PARTITION BY YEAR(order_date) ORDER by order_date) AS running_total 
FROM ( 
SELECT DATETRUNC(month, order_date) AS order_date, 
SUM(sales_amount) AS total_sales 
FROM gold.fact_sales 
WHERE order_date IS NOT NULL 
GROUP BY DATETRUNC(month, order_date))t

-- find running total without window function
SELECT
DATETRUNC(month, order_date) AS order_date,
SUM(sales_amount) AS total_sales,
SUM(SUM(sales_amount)) OVER (ORDER BY DATETRUNC(month, order_date) ROWS UNBOUNDED PRECEDING) AS running_total
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(month, order_date)

-- running total per year
SELECT order_date, total_sales, 
SUM(total_sales) OVER(ORDER by order_date) AS running_total,
AVG(avg_price) OVER(ORDER BY order_date) AS moving_average_price
FROM ( 
SELECT DATETRUNC(YEAR, order_date) AS order_date, 
SUM(sales_amount) AS total_sales,
AVG(price) AS avg_price
FROM gold.fact_sales 
WHERE order_date IS NOT NULL 
GROUP BY DATETRUNC(YEAR, order_date))t


-- Year over year performance analysis

WITH yearly_product_sales AS(
SELECT
YEAR(f.order_date) AS order_year,
p.product_name,
SUM(f.sales_amount) AS current_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
ON f.product_key = p.product_key
WHERE order_date IS NOT NULL
GROUP BY YEAR(f.order_date), p.product_name)
SELECT 
order_year,
product_name,
current_sales,
AVG(current_sales) OVER(PARTITION BY product_name) avg_sales,
current_sales - AVG(current_sales) OVER(PARTITION BY product_name) AS diff_avg,
CASE WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) > 0 THEN 'Above Avg'
	 WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) < 0 THEN 'Below Avg'
	 ELSE 'Average'
END avg_change,
LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) previous_year_sales,
current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) AS diff_previous_year,
CASE WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) > 0 THEN 'Above Avg'
	 WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) < 0 THEN 'Below Avg'
	 ELSE 'No change'
END prev_change
FROM yearly_product_sales
ORDER BY product_name, order_year;


-- Part of whole analysis

-- Find which category contribute the most sales
WITH category_sales AS (
SELECT p.category, SUM(sales_amount) total_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
ON f.product_key = p.product_key
GROUP BY category)

SELECT category, total_sales,
SUM(total_sales) OVER() overall_sales,
CONCAT(ROUND((CAST(total_sales AS FLOAT) / SUM(total_sales) OVER()) * 100, 2), '%') AS percentage_of_total
FROM category_sales
ORDER BY total_sales DESC;

-- Segment products into cost ranges and count products into each segment

WITH product_segment AS (
SELECT 
product_key, 
product_name,
cost,
CASE WHEN cost < 100 THEN 'Below 100'
	 WHEN cost BETWEEN 100 AND 500 THEN '100-500'
	 WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
	 ELSE 'Above 1000'
END cost_range
FROM gold.dim_products)

SELECT 
cost_range, 
COUNT(product_key) AS total_products
FROM product_segment
GROUP BY cost_range
ORDER BY total_products DESC;


-- Grouping customers based on their spending

WITH customer_spending AS (
SELECT 
c.customer_key,
c.first_name, 
c.last_name,
SUM(f.sales_amount) AS total_spending,
MIN(order_date) AS first_order,
MAX(order_date) AS last_order,
DATEDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
ON f.customer_key = c.customer_key
GROUP BY c.customer_key, c.first_name, c.last_name)

SELECT 
customer_key,
first_name, 
last_name,
total_spending,
lifespan,
CASE WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
	 WHEN lifespan >= 12 AND total_spending <=5000 THEN 'Regular'
	 ELSE 'New'
END customer_segment
FROM customer_spending;



WITH customer_spending AS (
SELECT 
c.customer_key,
c.first_name, 
c.last_name,
SUM(f.sales_amount) AS total_spending,
MIN(order_date) AS first_order,
MAX(order_date) AS last_order,
DATEDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
ON f.customer_key = c.customer_key
GROUP BY c.customer_key, c.first_name, c.last_name)

SELECT
customer_segment,
COUNT(customer_key) AS total_customers
FROM (SELECT 
customer_key,
CASE WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
	 WHEN lifespan >= 12 AND total_spending <=5000 THEN 'Regular'
	 ELSE 'New'
END customer_segment
FROM customer_spending)t
GROUP BY customer_segment
ORDER BY total_customers DESC;


-- Analysing key customer metrics and behaviours

CREATE VIEW gold.report_customers AS
WITH base_query AS(
 SELECT 
 f.order_number,
 f.product_key,
 f.order_date,
 f.sales_amount,
 f.quantity,
 c.customer_key,
 c.customer_number,
 CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
 DATEDIFF(year, c.birthdate, GETDATE()) age
 FROM gold.fact_sales f 
 LEFT JOIN gold.dim_customers c
 ON f.customer_key = c.customer_key
 WHERE order_date IS NOT NULL)
 
 , customer_aggregation AS(
 SELECT
 customer_key,
 customer_number,
 customer_name,
 age,
 COUNT(DISTINCT order_number) AS total_orders,
 SUM(sales_amount) AS total_sales,
 SUM(quantity) AS total_quantity,
 COUNT(DISTINCT product_key) AS total_products,
 MAX(order_date) AS last_order,
 DATEDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan
 FROM base_query
 GROUP BY customer_key, customer_number, customer_name, age)

 SELECT
 customer_key,
 customer_number,
 customer_name,
 age,
 CASE WHEN age < 20 THEN 'Under 20'
	  WHEN age between 20 and 29 THEN '20-29'
	  WHEN age between 30 and 39 THEN '30-39'
	  WHEN age between 40 and 49 THEN '40-49'
ELSE '50 and above'
END AS age_group,
 CASE WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
	 WHEN lifespan >= 12 AND total_sales <=5000 THEN 'Regular'
	 ELSE 'New'
END customer_segment,
DATEDIFF(month, last_order, GETDATE()) AS recency,
 total_orders,
 total_sales,
 total_quantity,
 total_products,
 last_order,
 lifespan,
 CASE WHEN total_orders = 0 THEN 0
 ELSE total_sales / total_orders
 END AS avg_order_value,
 CASE WHEN lifespan = 0 THEN total_sales
	  WHEN total_sales = 0 THEN 0
 ELSE total_sales / lifespan
 END AS avg_monthly_spend
 FROM customer_aggregation;

 SELECT * FROM gold.report_customers;


 CREATE VIEW gold.report_products AS
 WITH base_query AS(
 SELECT
 f.order_number,
 f.order_date,
 f.customer_key,
 f.sales_amount,
 f.quantity,
 p.product_key,
 p.product_name,
 p.category,
 p.subcategory,
 p.cost
 FROM gold.fact_sales f
 LEFT JOIN gold.dim_products p
 ON f.product_key = p.product_key
 WHERE order_date IS NOT NULL)

 ,product_aggregations AS (
 SELECT 
 product_key,
 product_name,
 category,
 subcategory,
 cost,
 DATEDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan,
 MAX(order_date) AS last_sale_date,
 COUNT(DISTINCT order_number) AS total_orders,
 COUNT(DISTINCT customer_key) AS total_customers,
 SUM(sales_amount) AS total_sales,
 SUM(quantity) AS total_quantity,
 ROUND(AVG(CAST(sales_amount AS FLOAT) / NULLIF(quantity, 0)),1) AS avg_selling_price
 FROM base_query
 GROUP BY product_key, product_name, category, subcategory, cost)

 SELECT 
 product_key,
 product_name,
 category,
 subcategory,
 cost,
 last_sale_date,
 DATEDIFF(month, last_sale_date, GETDATE()) AS recency_months,
 CASE WHEN total_sales > 5000 THEN 'High-Perfomer'
	  WHEN total_sales >- 10000 THEN 'Mid_range'
	  ELSE 'Low-Performer'
END AS product_segment,
lifespan,
total_orders,
total_sales,
total_quantity,
total_customers,
avg_selling_price,
 CASE WHEN total_orders = 0 THEN 0
 ELSE total_sales / total_orders
 END AS avg_order_revenue,
 CASE WHEN lifespan = 0 THEN total_sales
 ELSE total_sales / lifespan
 END AS avg_monthly_revenue

 FROM product_aggregations;
